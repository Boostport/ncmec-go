// Code generated by https://github.com/Boostport/ncmec-go/cybertipline; DO NOT EDIT.
package cybertipline

import (
	"encoding/xml"
	"time"

	"github.com/Boostport/ncmec-go"
)

// This is the main top level tag to define an incident report.
type Report struct {
	XMLName xml.Name `xml:"report"`
	// Report represents a batch of otherwise individual reports that have been grouped for the specified reason.
	BatchedReport *BatchedReport `xml:"batchedReport,omitempty"`
	// This contains general incident information.
	IncidentSummary *IncidentSummary `xml:"incidentSummary,omitempty"`
	// This record summarizes the details of the incident being reported. There can be more than one for different incident details, but there must be at least of these for each report.
	InternetDetails []InternetDetails `xml:"internetDetails,omitempty"`
	// The law enforcement contact information related to the event. This is used if the incident information has already been reported to law enforcement or if the request originated from law enforcement.
	LawEnforcement *LawEnforcement `xml:"lawEnforcement,omitempty"`
	// This is information related to the person or organization reporting the incident.
	Reporter *Reporter `xml:"reporter,omitempty"`
	// There can be 0 or 1 reported user or person involved in the incident.
	PersonOrUserReported *PersonOrUserReported `xml:"personOrUserReported,omitempty"`
	// There can be 0 or more intended recipients involved in the incident.
	IntendedRecipient []IntendedRecipient `xml:"intendedRecipient,omitempty"`
	// There can be 0 or more victim records for each incident.
	Victim []Victim `xml:"victim,omitempty"`
	// Any additional notes on this incident not covered by any other section.
	AdditionalInfo *string `xml:"additionalInfo,omitempty"`
}

type IncidentSummary struct {
	// This field describes the type of incident being reported.
	IncidentType IncidentType `xml:"incidentType,omitempty"`
	// The full application name where the reported content occurred.
	Platform *string `xml:"platform,omitempty"`
	// Company indicated a higher level of urgency (immediate risk to child) and the reason for this escalation. Only enter text if you want to escalate the report.
	EscalateToHighPriority *string `xml:"escalateToHighPriority,omitempty"`
	// Tags indicated by ESP to describe the reported incident.
	ReportAnnotations *ReportAnnotations `xml:"reportAnnotations,omitempty"`
	// The date/time of the reported incident.
	IncidentDateTime *time.Time `xml:"incidentDateTime,omitempty"`
	// This is a text field that allows you to enter any additional information related to the incidentDateTime.
	IncidentDateTimeDescription *string `xml:"incidentDateTimeDescription,omitempty"`
}

// This record summarizes the details of the incident being reported. There can be one or more for different incident details. Each record must have one of the following subtypes.
type InternetDetails struct {
	// The incident occurred on a web page.
	WebPageIncident *WebPageIncident `xml:"webPageIncident,omitempty"`
	// The incident occurred over Email.
	EmailIncident *EmailIncident `xml:"emailIncident,omitempty"`
	// The incident occurred in a newsgroup.
	NewsgroupIncident *NewsgroupIncident `xml:"newsgroupIncident,omitempty"`
	// The incident occurred over IM or during a chat session.
	ChatImIncident *ChatImIncident `xml:"chatImIncident,omitempty"`
	// The incident occurred during an online game.
	OnlineGamingIncident *OnlineGamingIncident `xml:"onlineGamingIncident,omitempty"`
	// This category is used when the primary method of communication between the child and/or reported person or user is through a cell phone. This can include phone conversations, text messages, or images sent through the phone.
	CellPhoneIncident *CellPhoneIncident `xml:"cellPhoneIncident,omitempty"`
	// This category of the incident does not involve an online or computer component or a cell phone (e.g., face-to-face contact or potentially illegal hard copy or printed materials).
	NonInternetIncident *NonInternetIncident `xml:"nonInternetIncident,omitempty"`
	// The incident occurred via a Peer to Peer (also known as P2P) decentralized network that allows users to share files through a direct connection.
	Peer2peerIncident *Peer2peerIncident `xml:"peer2peerIncident,omitempty"`
}

// The incident occurred on a web page.
type WebPageIncident struct {
	// This is the actual URL where the reported incident occurred. There can be as many of these as needed.
	Url []string `xml:"url,omitempty"`
	// This is a text field that allows you to enter any additional information related to the web page event.
	AdditionalInfo *string `xml:"additionalInfo,omitempty"`
}

// The incident occurred over email.
type EmailIncident struct {
	// An email address associated with the incident.
	EmailAddress []Email `xml:"emailAddress,omitempty"`
	// The headers, subject, and content of the communication.
	Content *string `xml:"content,omitempty"`
	// Any additional notes to add to the email event.
	AdditionalInfo *string `xml:"additionalInfo,omitempty"`
}

type NewsgroupIncident struct {
	// The newsgroup name.
	Name *string `xml:"name,omitempty"`
	// An email address associated with the incident.
	EmailAddress []Email `xml:"emailAddress,omitempty"`
	// The content of the newsgroup posting including any headers, subject.
	Content *string `xml:"content,omitempty"`
	// Any additional notes to add to the newsgroup event.
	AdditionalInfo *string `xml:"additionalInfo,omitempty"`
}

// The incident occurred over IM or during a chat session.
type ChatImIncident struct {
	// The chat or instant messenger program used.
	ChatClient *string `xml:"chatClient,omitempty"`
	// The name of the chat room.
	ChatRoomName *string `xml:"chatRoomName,omitempty"`
	// The content of the chat, any chat logs.
	Content *string `xml:"content,omitempty"`
	// Any additional information related to the chat/instant messaging incident.
	AdditionalInfo *string `xml:"additionalInfo,omitempty"`
}

// The incident occurred during an online game.
type OnlineGamingIncident struct {
	// The name of the game the incident occurred in.
	GameName *string `xml:"gameName,omitempty"`
	// The name of the gaming console if one was used.
	Console *string `xml:"console,omitempty"`
	// The content of the message/chat that occurred during the game.
	Content *string `xml:"content,omitempty"`
	// Any additional information about the online gaming incident.
	AdditionalInfo *string `xml:"additionalInfo,omitempty"`
}

// This category is used when the primary method of communication between the child and/or reported person or user is through a cell phone. This can include phone conversations, text messages, or images sent through the phone.
type CellPhoneIncident struct {
	// The cell phone number associated with the incident.
	PhoneNumber *Phone `xml:"phoneNumber,omitempty"`
	// The latitude associated with the incident.
	Latitude *float64 `xml:"latitude,omitempty"`
	// The longitude associated with the incident.
	Longitude *float64 `xml:"longitude,omitempty"`
	// Any additional information about the cell phone incident.
	AdditionalInfo *string `xml:"additionalInfo,omitempty"`
}

// This category of the incident does not involve an online or computer component or a cell phone (e.g., face-to-face contact or potentially illegal hard copy or printed materials).
type NonInternetIncident struct {
	// The location associated with the incident.
	LocationName *string `xml:"locationName,omitempty"`
	// Incident's address.
	IncidentAddress []Address `xml:"incidentAddress,omitempty"`
	// Please describe in detail the incident being reported.
	AdditionalInfo *string `xml:"additionalInfo,omitempty"`
}

// The incident occurred via a Peer to Peer (also known as P2P) decentralized network that allows users to share files through a direct connection.
type Peer2peerIncident struct {
	// The Peer to Peer Client used (e.g., Phex, Emule).
	Client *string `xml:"client,omitempty"`
	// An IP address used by the person or user reported.
	IpCaptureEvent []IpCaptureEvent `xml:"ipCaptureEvent,omitempty"`
	// The name of file(s).
	FileNames *string `xml:"fileNames,omitempty"`
	// Any additional information about the cell phone incident.
	AdditionalInfo *string `xml:"additionalInfo,omitempty"`
}

type ServedLegalProcessInternational struct {
	Value *bool `xml:",chardata"`
	// The name of the country associated with this report from which legal process was received.
	FleaCountry Country `xml:"fleaCountry,attr,omitempty"`
}

// The law enforcement contact information related to the event. This is used if the incident information has already been reported to law enforcement or if the request originated from law enforcement.
type LawEnforcement struct {
	// The law enforcement agency name involved.
	AgencyName *string `xml:"agencyName,omitempty"`
	// The case number if known.
	CaseNumber *string `xml:"caseNumber,omitempty"`
	// The contact information for the investigator or officer on the case.
	OfficerContact *ContactPerson `xml:"officerContact,omitempty"`
	// Set this to true if the incident was reported to law enforcement by the company.
	ReportedToLe *bool `xml:"reportedToLe,omitempty"`
	// Set this to true if domestic law enforcement has served legal process about this person/user or reported incident.
	ServedLegalProcessDomestic *bool `xml:"servedLegalProcessDomestic,omitempty"`
	// Set this to true if international law enforcement has served legal process about this person/user or reported incident.
	ServedLegalProcessInternational *ServedLegalProcessInternational `xml:"servedLegalProcessInternational,omitempty"`
}

// This is information related to the person or company reporting the incident.
type Reporter struct {
	// Details of the person reporting the information and the company's address.
	ReportingPerson *Person `xml:"reportingPerson,omitempty"`
	// Use this field if a person other than the person submitting the report should be contacted by law enforcement regarding the report.
	ContactPerson *ContactPerson `xml:"contactPerson,omitempty"`
	// This open-text field allows a company to include language (not specific to the reported incident) that they want included in every CyberTipline report. For instance, basic company information, how legal process should be served, length of data retention, 24-hour emergency phone numbers, etc..
	CompanyTemplate *string `xml:"companyTemplate,omitempty"`
	// Include Terms of Service (TOS) relevant to the incident being reported.
	TermsOfService *string `xml:"termsOfService,omitempty"`
	// Company can include a URL if they wish to direct attention to a web page for further information.
	LegalURL *string `xml:"legalURL,omitempty"`
}

type PersonOrUserReported struct {
	// The person information about the reported person or user in the incident.
	PersonOrUserReportedPerson *Person `xml:"personOrUserReportedPerson,omitempty"`
	// The description for the vehicle of the reported person.
	VehicleDescription *string `xml:"vehicleDescription,omitempty"`
	// The unique ID of the reported person or user in the ESP's system (e.g., friend ID).
	EspIdentifier *string `xml:"espIdentifier,omitempty"`
	// The name of the reporter's product or service that was used by the reported person or user during the incident.
	EspService *string `xml:"espService,omitempty"`
	// This account has been compromised, hacked, or hijacked.
	CompromisedAccount *bool `xml:"compromisedAccount,omitempty"`
	// The screen name of the reported person or user.
	ScreenName *string `xml:"screenName,omitempty"`
	// A display name, other than a screen name or a username, for the reported person or user.
	DisplayName []string `xml:"displayName,omitempty"`
	// The different identifying URLs for this reported person or user.
	ProfileUrl []string `xml:"profileUrl,omitempty"`
	// A copy of the user's bio as per their account according to the reporting company's platform.
	ProfileBio *string `xml:"profileBio,omitempty"`
	// An originating IP address used by the reported person or user and when it was used.
	IpCaptureEvent []IpCaptureEvent `xml:"ipCaptureEvent,omitempty"`
	// An ID for a device used by the reported person or user and, optionally, when it was used.
	DeviceId []DeviceId `xml:"deviceId,omitempty"`
	// Reported person or user is using another company's service. The reporting company has no further information about this person or user.
	ThirdPartyUserReported *bool `xml:"thirdPartyUserReported,omitempty"`
	// List report ID numbers for any prior CyberTipline reports on this reported person or user.
	PriorCTReports []int64 `xml:"priorCTReports,omitempty"`
	// The ESP believes the reported person or user is engaged in an organized online group related to child sexual exploitation. This open text field is used to provide unique group identifiers (e.g., group name, group ID, etc.).
	GroupIdentifier *string `xml:"groupIdentifier,omitempty"`
	// Whether the account was temporarily disabled at any point.
	AccountTemporarilyDisabled *AccountTemporarilyDisabled `xml:"accountTemporarilyDisabled,omitempty"`
	// Whether the account was permanently disabled.
	AccountPermanentlyDisabled *AccountPermanentlyDisabled `xml:"accountPermanentlyDisabled,omitempty"`
	// The reporter's estimated location for the reported person or user.
	EstimatedLocation *EstimatedLocation `xml:"estimatedLocation,omitempty"`
	// There are no additional emails to report.
	AllEmailsReported *bool `xml:"allEmailsReported,omitempty"`
	// Any additional account associated with this reported person or user.
	AssociatedAccount []AssociatedAccount `xml:"associatedAccount,omitempty"`
	// Any additional notes on this reported person or user not covered by any other section
	AdditionalInfo *string `xml:"additionalInfo,omitempty"`
}

type IntendedRecipient struct {
	// The person information about the intended recipient.
	IntendedRecipientPerson *Person `xml:"intendedRecipientPerson,omitempty"`
	// The unique ID of the intended recipient in the ESP's system (e.g., friend ID).
	EspIdentifier *string `xml:"espIdentifier,omitempty"`
	// The name of the reporter's product or service that was used by the intended recipient during the incident.
	EspService *string `xml:"espService,omitempty"`
	// This account has been compromised, hacked, or hijacked.
	CompromisedAccount *bool `xml:"compromisedAccount,omitempty"`
	// The screen name of the intended recipient.
	ScreenName *string `xml:"screenName,omitempty"`
	// A display name, other than a screen name or a username, for the intended recipient.
	DisplayName []string `xml:"displayName,omitempty"`
	// An identifying URL for this intended recipient.
	ProfileUrl []string `xml:"profileUrl,omitempty"`
	// A copy of the user's bio as per their account according to the reporting company's platform.
	ProfileBio *string `xml:"profileBio,omitempty"`
	// An IP address used by the intended recipient and when it was used.
	IpCaptureEvent []IpCaptureEvent `xml:"ipCaptureEvent,omitempty"`
	// An ID for a device used by the intended recipient and when it was used.
	DeviceId []DeviceId `xml:"deviceId,omitempty"`
	// A CyberTipline report ID for any prior CyberTipline report on this intended recipient.
	PriorCTReports []int64 `xml:"priorCTReports,omitempty"`
	// The ESP believes the intended recipient is engaged in an organized online group related to child sexual exploitation. This open text field is used to provide unique group identifiers (e.g., group name, group ID, etc.).
	GroupIdentifier *string `xml:"groupIdentifier,omitempty"`
	// Whether the account was temporarily disabled at any point.
	AccountTemporarilyDisabled *AccountTemporarilyDisabled `xml:"accountTemporarilyDisabled,omitempty"`
	// Whether the account was permanently disabled.
	AccountPermanentlyDisabled *AccountPermanentlyDisabled `xml:"accountPermanentlyDisabled,omitempty"`
	// The reporter's estimated location for the intended recipient.
	EstimatedLocation *EstimatedLocation `xml:"estimatedLocation,omitempty"`
	// There are no additional emails to report.
	AllEmailsReported *bool `xml:"allEmailsReported,omitempty"`
	// Additional information about this intended recipient not covered by any other section.
	AdditionalInfo []string `xml:"additionalInfo,omitempty"`
}

// There can be 0 or more victim records for each incident.
type Victim struct {
	// The victim's personal details such as name, address, phone numbers.
	VictimPerson *Person `xml:"victimPerson,omitempty"`
	// The unique ID of the victim in the ESP's system (e.g., friend ID).
	EspIdentifier *string `xml:"espIdentifier,omitempty"`
	// The name of the reporter's product or service that was used by the victim during the incident.
	EspService *string `xml:"espService,omitempty"`
	// This account has been compromised, hacked, or hijacked.
	CompromisedAccount *bool `xml:"compromisedAccount,omitempty"`
	// The screen name of the victim.
	ScreenName *string `xml:"screenName,omitempty"`
	// A display name, other than a screen name or a username, for the victim.
	DisplayName []string `xml:"displayName,omitempty"`
	// The identifying URL(s) for the victim.
	ProfileUrl []string `xml:"profileUrl,omitempty"`
	// A copy of the user's bio as per their account according to the reporting company's platform.
	ProfileBio *string `xml:"profileBio,omitempty"`
	// An originating IP address used by the victim and when it was used.
	IpCaptureEvent []IpCaptureEvent `xml:"ipCaptureEvent,omitempty"`
	// An ID for a device used by the victim and, optionally, when it was used.
	DeviceId []DeviceId `xml:"deviceId,omitempty"`
	// Victim's school name.
	SchoolName *string `xml:"schoolName,omitempty"`
	// List of report ID numbers for any prior CyberTipline reports on this victim.
	PriorCTReports []int64 `xml:"priorCTReports,omitempty"`
	// Whether the account was temporarily disabled at any point.
	AccountTemporarilyDisabled *AccountTemporarilyDisabled `xml:"accountTemporarilyDisabled,omitempty"`
	// Whether the account was permanently disabled.
	AccountPermanentlyDisabled *AccountPermanentlyDisabled `xml:"accountPermanentlyDisabled,omitempty"`
	// The reporter's estimated location for the victim.
	EstimatedLocation *EstimatedLocation `xml:"estimatedLocation,omitempty"`
	// There are no additional emails to report.
	AllEmailsReported *bool `xml:"allEmailsReported,omitempty"`
	// Any additional account associated with this victim.
	AssociatedAccount []AssociatedAccount `xml:"associatedAccount,omitempty"`
	// Any additional notes on this victim.
	AdditionalInfo *string `xml:"additionalInfo,omitempty"`
}

// The root element of the file details.
type FileDetails struct {
	XMLName xml.Name `xml:"fileDetails"`
	// The report this file is related to.
	ReportId *int64 `xml:"reportId,omitempty"`
	// The file this report is related to.
	FileId *string `xml:"fileId,omitempty"`
	// The name of the file being reported to NCMEC by the company.
	FileName *string `xml:"fileName,omitempty"`
	// Original filename associated with the file when it was uploaded to the company's servers by the reported user or person.
	OriginalFileName *string `xml:"originalFileName,omitempty"`
	// The date and time the file was uploaded to the reporting ESP.
	UploadedToEspTimestamp *time.Time `xml:"uploadedToEspTimestamp,omitempty"`
	// The URL where reported file was originally located.
	LocationOfFile *string `xml:"locationOfFile,omitempty"`
	// Has your company viewed the file being reported to NCMEC?
	FileViewedByEsp *bool `xml:"fileViewedByEsp,omitempty"`
	// Has your company viewed the EXIF for the file being reported to NCMEC?
	ExifViewedByEsp *bool `xml:"exifViewedByEsp,omitempty"`
	// Was the reported file publicly accessible to online users?
	PubliclyAvailable *bool `xml:"publiclyAvailable,omitempty"`
	// The relevance or relation of the uploaded file to the report. Unless specified otherwise, a file is "Reported" by default.
	FileRelevance FileRelevance `xml:"fileRelevance,omitempty"`
	// Is the file being shared/posted out of mimicry or other seemingly non-malicious intent?
	PotentialMeme *bool `xml:"potentialMeme,omitempty"`
	// Tags indicated by ESP to describe the reported file.
	FileAnnotations *FileAnnotations `xml:"fileAnnotations,omitempty"`
	// This field should be used only if your company has executed the MOU to participate in the Industry Hash Sharing Platform. Only populate with Industry-created classification scale (A1, A2, B1, or B2).
	IndustryClassification FileClassification `xml:"industryClassification,omitempty"`
	// The original binary hash value of the file at the time it was uploaded by the reported user or person (prior to any potential modification by your company). Include required attribute hashType, specifying the type of hash submitted, e.g., MD5, SHA1, etc.
	OriginalFileHash []Hash `xml:"originalFileHash,omitempty"`
	// This represents the upload IP address of the file and when it occurred.
	IpCaptureEvent *IpCaptureEvent `xml:"ipCaptureEvent,omitempty"`
	// An ID for a device used to upload the file and, optionally, when it was used.
	DeviceId []DeviceId `xml:"deviceId,omitempty"`
	Details  []Details  `xml:"details,omitempty"`
	// Additional information regarding the uploaded file your company wishes to report (e.g., "viral video").
	AdditionalInfo []string `xml:"additionalInfo,omitempty"`
}

// All the file meta data name value pairs.
type Details struct {
	// The list of meta data.
	NameValuePair []NameValue `xml:"nameValuePair,omitempty"`
}

// This element is the root element of the response to a report, file or file details submittal.
type ReportResponse struct {
	XMLName xml.Name `xml:"reportResponse"`
	// The response code returned from the submittal. 0 is success, any non-zero number is an error code defined in the documentation.
	ResponseCode *int `xml:"responseCode,omitempty"`
	// The description of the error code or empty if the response is success.
	ResponseDescription *string `xml:"responseDescription,omitempty"`
	// The report ID about which this submittal is related.
	ReportId *int64 `xml:"reportId,omitempty"`
	// If a file was uploaded, the file ID of the file.
	FileId *string `xml:"fileId,omitempty"`
	// If a file was uploaded, the md5 hash of the file.
	Hash *string `xml:"hash,omitempty"`
}

type Files struct {
	FileId []string `xml:"fileId,omitempty"`
}

// The final response from the server once the report has been submitted, all files and file details have been uploaded and the report done has been submitted.
type ReportDoneResponse struct {
	XMLName xml.Name `xml:"reportDoneResponse"`
	// The response code returned from the submittal. 0 is success, any non-zero number is an error code defined in the documentation.
	ResponseCode *int   `xml:"responseCode,omitempty"`
	ReportId     *int64 `xml:"reportId,omitempty"`
	// The list of files successfully uploaded.
	Files  *Files   `xml:"files,omitempty"`
	FileId []string `xml:"fileId,omitempty"`
}

type ReportAnnotations struct {
	// Is the report associated with sextortion?
	Sextortion *bool `xml:"sextortion,omitempty"`
	// Is the report associated with solicitation for child sexual assault material?
	CsamSolicitation *bool `xml:"csamSolicitation,omitempty"`
	// Is the report associated with an interaction between minors?
	MinorToMinorInteraction *bool `xml:"minorToMinorInteraction,omitempty"`
	// Is the report associated with spam?
	Spam *bool `xml:"spam,omitempty"`
	// Is the report associated with sadistic online exploitation?
	SadisticOnlineExploitation *bool `xml:"sadisticOnlineExploitation,omitempty"`
}

// A person record. Can be used to represent a reported person or user, victim, or reporting person.
type Person struct {
	// Person's first name.
	FirstName *string `xml:"firstName,omitempty"`
	// Person's last name.
	LastName *string `xml:"lastName,omitempty"`
	// Phone number and type.
	Phone []Phone `xml:"phone,omitempty"`
	// Contact email address (type and if verified).
	Email []Email `xml:"email,omitempty"`
	// Person's address.
	Address []Address `xml:"address,omitempty"`
	// Person's age.
	Age *int `xml:"age,omitempty"`
	// Person's date of birth.
	DateOfBirth *ncmec.Date `xml:"dateOfBirth,omitempty"`
}

// A person record with information pertinent for contact.
type ContactPerson struct {
	// Person's first name.
	FirstName *string `xml:"firstName,omitempty"`
	// Person's last name.
	LastName *string `xml:"lastName,omitempty"`
	// Phone number and type.
	Phone []Phone `xml:"phone,omitempty"`
	// Contact email address (type and if verified).
	Email []Email `xml:"email,omitempty"`
	// Person's address.
	Address []Address `xml:"address,omitempty"`
}

type Address struct {
	// Street Address.
	Address *string `xml:"address,omitempty"`
	// City.
	City *string `xml:"city,omitempty"`
	// Zip or postal code.
	ZipCode *string `xml:"zipCode,omitempty"`
	// US State or territory.
	State State `xml:"state,omitempty"`
	// If not in the United States, the state or province.
	NonUsaState *string `xml:"nonUsaState,omitempty"`
	// Country name or two letter country code.
	Country Country `xml:"country,omitempty"`
	// The type of address.
	Type AddressType `xml:"type,attr,omitempty"`
}

type Email struct {
	Value            *string    `xml:",chardata"`
	Type             EmailType  `xml:"type,attr,omitempty"`
	Verified         *bool      `xml:"verified,attr,omitempty"`
	VerificationDate *time.Time `xml:"verificationDate,attr,omitempty"`
}

// The complex type phone contains the phone number and if available, the phone type.
type Phone struct {
	Value              *string    `xml:",chardata"`
	Type               PhoneType  `xml:"type,attr,omitempty"`
	Verified           *bool      `xml:"verified,attr,omitempty"`
	VerificationDate   *time.Time `xml:"verificationDate,attr,omitempty"`
	CountryCallingCode *string    `xml:"countryCallingCode,attr,omitempty"`
	Extension          *string    `xml:"extension,attr,omitempty"`
}

type EstimatedLocation struct {
	City        *string    `xml:"city,omitempty"`
	Region      *string    `xml:"region,omitempty"`
	CountryCode Country    `xml:"countryCode,omitempty"`
	Verified    *bool      `xml:"verified,attr,omitempty"`
	Timestamp   *time.Time `xml:"timestamp,attr,omitempty"`
}

type BatchedReport struct {
	Reason BatchedReportReason `xml:"reason,attr,omitempty"`
}

// This represents the origination IP address of an action and when it occurred.
type IpCaptureEvent struct {
	// The IP address from which the incident occurred.
	IpAddress *string `xml:"ipAddress,omitempty"`
	// Type of IP Address reported, e.g., Login, Registration, Upload, etc.
	EventName IpCaptureType `xml:"eventName,omitempty"`
	// The time the incident occurred and the IP address was recorded.
	DateTime *time.Time `xml:"dateTime,omitempty"`
	// If the ESP has reason to believe this IP address is a proxy, please indicate this here.
	PossibleProxy *bool `xml:"possibleProxy,omitempty"`
	// The port number of the IP address.
	Port *int `xml:"port,omitempty"`
}

// This represents the capture of a device ID.
type DeviceId struct {
	// The type of device ID captured, e.g., IMEI, ICCID, SSID, etc..
	IdType *string `xml:"idType,omitempty"`
	// The value of the ID captured.
	IdValue *string `xml:"idValue,omitempty"`
	// Event during which the company recorded the device ID capture reported, e.g., Login, Registration, Upload, etc..
	EventName IpCaptureType `xml:"eventName,omitempty"`
	// The time the incident occurred and the device ID was recorded.
	DateTime *time.Time `xml:"dateTime,omitempty"`
}

type AccountTemporarilyDisabled struct {
	Value            *bool      `xml:",chardata"`
	DisabledDate     *time.Time `xml:"disabledDate,attr,omitempty"`
	UserNotified     *bool      `xml:"userNotified,attr,omitempty"`
	UserNotifiedDate *time.Time `xml:"userNotifiedDate,attr,omitempty"`
	ReenabledDate    *time.Time `xml:"reenabledDate,attr,omitempty"`
}

type AccountPermanentlyDisabled struct {
	Value            *bool      `xml:",chardata"`
	DisabledDate     *time.Time `xml:"disabledDate,attr,omitempty"`
	UserNotified     *bool      `xml:"userNotified,attr,omitempty"`
	UserNotifiedDate *time.Time `xml:"userNotifiedDate,attr,omitempty"`
}

type Platform struct {
	Value          *string `xml:",chardata"`
	ThirdPartyUser *bool   `xml:"thirdPartyUser,attr,omitempty"`
}

type AssociatedAccount struct {
	Platform *Platform `xml:"platform,omitempty"`
	// Associated account person's first name.
	FirstName *string `xml:"firstName,omitempty"`
	// Associated account person's middle name.
	MiddleName *string `xml:"middleName,omitempty"`
	// Associated account person's last name.
	LastName *string `xml:"lastName,omitempty"`
	// Associated account person's approximate age.
	ApproximateAge *int `xml:"approximateAge,omitempty"`
	// Associated account person's date of birth.
	DateOfBirth *ncmec.Date `xml:"dateOfBirth,omitempty"`
	// Contact phone number (type and if verified).
	Phone []Phone `xml:"phone,omitempty"`
	// Contact email address (type and if verified).
	Email []Email `xml:"email,omitempty"`
	// There are no additional emails to report.
	AllEmailsReported *bool `xml:"allEmailsReported,omitempty"`
	// Associated account's address.
	Address []Address `xml:"address,omitempty"`
	// The name of the reporter's product or service that was used by the associated account during the incident.
	EspService *string `xml:"espService,omitempty"`
	// The unique ID of the associated account in the ESP's system (e.g., friend ID).
	EspIdentifier *string `xml:"espIdentifier,omitempty"`
	// The identifying URL(s) for the associated account.
	ProfileUrl []string `xml:"profileUrl,omitempty"`
	// The screen name of the associated account.
	ScreenName *string `xml:"screenName,omitempty"`
	// A display name, other than a screen name or a username, for the associated account.
	DisplayName []string `xml:"displayName,omitempty"`
	// A copy of the user's bio as per their account according to the associated account's platform.
	ProfileBio *string `xml:"profileBio,omitempty"`
	// The ESP believes the associated account is engaged in an organized online group related to child sexual exploitation. This open text field is used to provide unique group identifiers (e.g., group name, group ID, etc.).
	GroupIdentifier *string `xml:"groupIdentifier,omitempty"`
	// This account has been compromised, hacked, or hijacked.
	CompromisedAccount *bool `xml:"compromisedAccount,omitempty"`
	// Whether the account was temporarily disabled at any point.
	AccountTemporarilyDisabled *AccountTemporarilyDisabled `xml:"accountTemporarilyDisabled,omitempty"`
	// Whether the account was permanently disabled.
	AccountPermanentlyDisabled *AccountPermanentlyDisabled `xml:"accountPermanentlyDisabled,omitempty"`
	// An originating IP address used by the associated account and when it was used.
	IpCaptureEvent []IpCaptureEvent `xml:"ipCaptureEvent,omitempty"`
	// An ID for a device used by the associated account and, optionally, when it was used.
	DeviceId []DeviceId `xml:"deviceId,omitempty"`
	// List of report ID numbers for any prior CyberTipline reports on this associated account.
	PriorCTReport []int64 `xml:"priorCTReport,omitempty"`
	// Any additional notes on this associated account.
	AdditionalInfo *string               `xml:"additionalInfo,omitempty"`
	Type           AssociatedAccountType `xml:"type,attr,omitempty"`
}

type FileAnnotations struct {
	// Is the file depicting anime, drawing, cartoon, virtual or hentai?
	AnimeDrawingVirtualHentai *bool `xml:"animeDrawingVirtualHentai,omitempty"`
	// Is the file being shared/posted out of mimicry or other seemingly non-malicious intent?
	PotentialMeme *bool `xml:"potentialMeme,omitempty"`
	// Is the file circulating rapidly from one user to another?
	Viral *bool `xml:"viral,omitempty"`
	// Does the file contain content that is believed to be self- produced?
	PossibleSelfProduction *bool `xml:"possibleSelfProduction,omitempty"`
	// Does the file depict an intentional act of causing physical injury or trauma to a person?
	PhysicalHarm *bool `xml:"physicalHarm,omitempty"`
	// Does the file depict graphic violence, including but not limited to acts of brutality or detailed or vivid gruesomeness?
	ViolenceGore *bool `xml:"violenceGore,omitempty"`
	// Does the file involve an animal(s)?
	Bestiality *bool `xml:"bestiality,omitempty"`
	// Does the file depicts content that was streamed live at the time it was uploaded?
	LiveStreaming *bool `xml:"liveStreaming,omitempty"`
	// Does the file depict an infant?
	Infant *bool `xml:"infant,omitempty"`
	// Does the file contain content that is believed to be Generative Artificial Intelligence?
	GenerativeAi *bool `xml:"generativeAi,omitempty"`
}

// The complex type hash contains a hash and hash type.
type Hash struct {
	Value    *string `xml:",chardata"`
	HashType *string `xml:"hashType,attr,omitempty"`
}

type NameValue struct {
	// The name of the meta data variable.
	Name *string `xml:"name,omitempty"`
	// The value of the meta data variable.
	Value *string `xml:"value,omitempty"`
}

type AddressType string

const (
	AddressTypeHome      AddressType = "Home"
	AddressTypeBusiness  AddressType = "Business"
	AddressTypeBilling   AddressType = "Billing"
	AddressTypeShipping  AddressType = "Shipping"
	AddressTypeTechnical AddressType = "Technical"
)

func (s AddressType) StringPtr() *string {
	str := string(s)
	return &str
}

type EmailType string

const (
	EmailTypeHome     EmailType = "Home"
	EmailTypeWork     EmailType = "Work"
	EmailTypeBusiness EmailType = "Business"
	EmailTypeRecovery EmailType = "Recovery"
)

func (s EmailType) StringPtr() *string {
	str := string(s)
	return &str
}

type PhoneType string

const (
	PhoneTypeMobile   PhoneType = "Mobile"
	PhoneTypeHome     PhoneType = "Home"
	PhoneTypeBusiness PhoneType = "Business"
	PhoneTypeWork     PhoneType = "Work"
	PhoneTypeFax      PhoneType = "Fax"
	PhoneTypeInternet PhoneType = "Internet"
	PhoneTypeRecovery PhoneType = "Recovery"
)

func (s PhoneType) StringPtr() *string {
	str := string(s)
	return &str
}

type BatchedReportReason string

const (
	BatchedReportReasonViralPotentialMeme BatchedReportReason = "VIRAL_POTENTIAL_MEME"
)

func (s BatchedReportReason) StringPtr() *string {
	str := string(s)
	return &str
}

// This is an enumeration of all supported incident types. Originally, we only supported child pornography, but we have expanded to support child sex trafficking, child sex tourism, sexual molestation, misleading domain names, misleading worlds or images, online enticement, or unsolicited obscene material to a child.
type IncidentType string

const (
	IncidentTypeChildPornographyPossessionManufactureAndDistribution IncidentType = "Child Pornography (possession, manufacture, and distribution)"
	IncidentTypeChildSexTrafficking                                  IncidentType = "Child Sex Trafficking"
	IncidentTypeChildSexTourism                                      IncidentType = "Child Sex Tourism"
	IncidentTypeChildSexualMolestation                               IncidentType = "Child Sexual Molestation"
	IncidentTypeMisleadingDomainName                                 IncidentType = "Misleading Domain Name"
	IncidentTypeMisleadingWordsOrDigitalImagesOnTheInternet          IncidentType = "Misleading Words or Digital Images on the Internet"
	IncidentTypeOnlineEnticementOfChildrenForSexualActs              IncidentType = "Online Enticement of Children for Sexual Acts"
	IncidentTypeUnsolicitedObsceneMaterialSentToAChild               IncidentType = "Unsolicited Obscene Material Sent to a Child"
)

func (s IncidentType) StringPtr() *string {
	str := string(s)
	return &str
}

// This defines the type of URL. Types include login, registration, etc. The available options are enumerated in the schema.
type IpCaptureType string

const (
	IpCaptureTypeLogin        IpCaptureType = "Login"
	IpCaptureTypeRegistration IpCaptureType = "Registration"
	IpCaptureTypePurchase     IpCaptureType = "Purchase"
	IpCaptureTypeUpload       IpCaptureType = "Upload"
	IpCaptureTypeOther        IpCaptureType = "Other"
	IpCaptureTypeUnknown      IpCaptureType = "Unknown"
)

func (s IpCaptureType) StringPtr() *string {
	str := string(s)
	return &str
}

type AssociatedAccountType string

const (
	AssociatedAccountTypeBilling        AssociatedAccountType = "Billing"
	AssociatedAccountTypeLinked         AssociatedAccountType = "Linked"
	AssociatedAccountTypeBusiness       AssociatedAccountType = "Business"
	AssociatedAccountTypeCreator        AssociatedAccountType = "Creator"
	AssociatedAccountTypeParentGuardian AssociatedAccountType = "Parent/Guardian"
	AssociatedAccountTypeOther          AssociatedAccountType = "Other"
)

func (s AssociatedAccountType) StringPtr() *string {
	str := string(s)
	return &str
}

type FileRelevance string

const (
	FileRelevanceReported             FileRelevance = "Reported"
	FileRelevanceSupplementalReported FileRelevance = "Supplemental Reported"
)

func (s FileRelevance) StringPtr() *string {
	str := string(s)
	return &str
}

type FileClassification string

const (
	FileClassificationA1 FileClassification = "A1"
	FileClassificationA2 FileClassification = "A2"
	FileClassificationB1 FileClassification = "B1"
	FileClassificationB2 FileClassification = "B2"
)

func (s FileClassification) StringPtr() *string {
	str := string(s)
	return &str
}

type MetadataTypes string

const (
	MetadataTypesEXIF MetadataTypes = "EXIF"
	MetadataTypesHash MetadataTypes = "HASH"
)

func (s MetadataTypes) StringPtr() *string {
	str := string(s)
	return &str
}

// This type supports the code of countries specified in the list of ISO 3166 Country Codes.
type Country string

const (
	CountryUnknown Country = ""
	// Anonymous Proxy
	CountryA1 Country = "A1"
	// Satellite Provider
	CountryA2 Country = "A2"
	// Other Country
	CountryO1 Country = "O1"
	// Andorra
	CountryAD Country = "AD"
	// United Arab Emirates
	CountryAE Country = "AE"
	// Afghanistan
	CountryAF Country = "AF"
	// Antigua and Barbuda
	CountryAG Country = "AG"
	// Anguilla
	CountryAI Country = "AI"
	// Albania
	CountryAL Country = "AL"
	// Armenia
	CountryAM Country = "AM"
	// Netherlands Antilles
	CountryAN Country = "AN"
	// Angola
	CountryAO Country = "AO"
	// Asia/Pacific Region
	CountryAP Country = "AP"
	// Antarctica
	CountryAQ Country = "AQ"
	// Argentina
	CountryAR Country = "AR"
	// American Samoa
	CountryAS Country = "AS"
	// Austria
	CountryAT Country = "AT"
	// Australia
	CountryAU Country = "AU"
	// Aruba
	CountryAW Country = "AW"
	// Aland Islands
	CountryAX Country = "AX"
	// Azerbaijan
	CountryAZ Country = "AZ"
	// Bosnia and Herzegovina
	CountryBA Country = "BA"
	// Barbados
	CountryBB Country = "BB"
	// Bangladesh
	CountryBD Country = "BD"
	// Belgium
	CountryBE Country = "BE"
	// Burkina Faso
	CountryBF Country = "BF"
	// Bulgaria
	CountryBG Country = "BG"
	// Bahrain
	CountryBH Country = "BH"
	// Burundi
	CountryBI Country = "BI"
	// Benin
	CountryBJ Country = "BJ"
	// Saint Bartelemey
	CountryBL Country = "BL"
	// Bermuda
	CountryBM Country = "BM"
	// Brunei Darussalam
	CountryBN Country = "BN"
	// Bolivia
	CountryBO Country = "BO"
	// Bonaire, Sint Eustatius and Saba
	CountryBQ Country = "BQ"
	// Brazil
	CountryBR Country = "BR"
	// Bahamas
	CountryBS Country = "BS"
	// Bhutan
	CountryBT Country = "BT"
	// Bouvet Island
	CountryBV Country = "BV"
	// Botswana
	CountryBW Country = "BW"
	// Belarus
	CountryBY Country = "BY"
	// Belize
	CountryBZ Country = "BZ"
	// Canada
	CountryCA Country = "CA"
	// Cocos (Keeling) Islands
	CountryCC Country = "CC"
	// Congo, The Democratic Republic of the
	CountryCD Country = "CD"
	// Central African Republic
	CountryCF Country = "CF"
	// Congo
	CountryCG Country = "CG"
	// Switzerland
	CountryCH Country = "CH"
	// Cote d'Ivoire
	CountryCI Country = "CI"
	// Cook Islands
	CountryCK Country = "CK"
	// Chile
	CountryCL Country = "CL"
	// Cameroon
	CountryCM Country = "CM"
	// China
	CountryCN Country = "CN"
	// Colombia
	CountryCO Country = "CO"
	// Costa Rica
	CountryCR Country = "CR"
	// Cuba
	CountryCU Country = "CU"
	// Cape Verde
	CountryCV Country = "CV"
	// Christmas Island
	CountryCX Country = "CX"
	// Curacao
	CountryCW Country = "CW"
	// Cyprus
	CountryCY Country = "CY"
	// Czech Republic
	CountryCZ Country = "CZ"
	// Germany
	CountryDE Country = "DE"
	// Djibouti
	CountryDJ Country = "DJ"
	// Denmark
	CountryDK Country = "DK"
	// Dominica
	CountryDM Country = "DM"
	// Dominican Republic
	CountryDO Country = "DO"
	// Algeria
	CountryDZ Country = "DZ"
	// Ecuador
	CountryEC Country = "EC"
	// Estonia
	CountryEE Country = "EE"
	// Egypt
	CountryEG Country = "EG"
	// Western Sahara
	CountryEH Country = "EH"
	// Eritrea
	CountryER Country = "ER"
	// Spain
	CountryES Country = "ES"
	// Ethiopia
	CountryET Country = "ET"
	// Europe
	CountryEU Country = "EU"
	// Finland
	CountryFI Country = "FI"
	// Fiji
	CountryFJ Country = "FJ"
	// Falkland Islands (Malvinas)
	CountryFK Country = "FK"
	// Micronesia, Federated States of
	CountryFM Country = "FM"
	// Faroe Islands
	CountryFO Country = "FO"
	// France
	CountryFR Country = "FR"
	// France, Metropolitan
	CountryFX Country = "FX"
	// Gabon
	CountryGA Country = "GA"
	// United Kingdom
	CountryGB Country = "GB"
	// Grenada
	CountryGD Country = "GD"
	// Georgia
	CountryGE Country = "GE"
	// French Guiana
	CountryGF Country = "GF"
	// Guernsey
	CountryGG Country = "GG"
	// Ghana
	CountryGH Country = "GH"
	// Gibraltar
	CountryGI Country = "GI"
	// Greenland
	CountryGL Country = "GL"
	// Gambia
	CountryGM Country = "GM"
	// Guinea
	CountryGN Country = "GN"
	// Guadeloupe
	CountryGP Country = "GP"
	// Equatorial Guinea
	CountryGQ Country = "GQ"
	// Greece
	CountryGR Country = "GR"
	// South Georgia and the South Sandwich Islands
	CountryGS Country = "GS"
	// Guatemala
	CountryGT Country = "GT"
	// Guam
	CountryGU Country = "GU"
	// Guinea-Bissau
	CountryGW Country = "GW"
	// Guyana
	CountryGY Country = "GY"
	// Hong Kong
	CountryHK Country = "HK"
	// Heard Island and McDonald Islands
	CountryHM Country = "HM"
	// Honduras
	CountryHN Country = "HN"
	// Croatia
	CountryHR Country = "HR"
	// Haiti
	CountryHT Country = "HT"
	// Hungary
	CountryHU Country = "HU"
	// Indonesia
	CountryID Country = "ID"
	// Ireland
	CountryIE Country = "IE"
	// Israel
	CountryIL Country = "IL"
	// Isle of Man
	CountryIM Country = "IM"
	// India
	CountryIN Country = "IN"
	// British Indian Ocean Territory
	CountryIO Country = "IO"
	// Iraq
	CountryIQ Country = "IQ"
	// Iran, Islamic Republic of
	CountryIR Country = "IR"
	// Iceland
	CountryIS Country = "IS"
	// Italy
	CountryIT Country = "IT"
	// Jersey
	CountryJE Country = "JE"
	// Jamaica
	CountryJM Country = "JM"
	// Jordan
	CountryJO Country = "JO"
	// Japan
	CountryJP Country = "JP"
	// Kenya
	CountryKE Country = "KE"
	// Kyrgyzstan
	CountryKG Country = "KG"
	// Cambodia
	CountryKH Country = "KH"
	// Kiribati
	CountryKI Country = "KI"
	// Comoros
	CountryKM Country = "KM"
	// Saint Kitts and Nevis
	CountryKN Country = "KN"
	// Korea, Democratic People's Republic of
	CountryKP Country = "KP"
	// Korea, Republic of
	CountryKR Country = "KR"
	// Kuwait
	CountryKW Country = "KW"
	// Cayman Islands
	CountryKY Country = "KY"
	// Kazakhstan
	CountryKZ Country = "KZ"
	// Lao People's Democratic Republic
	CountryLA Country = "LA"
	// Lebanon
	CountryLB Country = "LB"
	// Saint Lucia
	CountryLC Country = "LC"
	// Liechtenstein
	CountryLI Country = "LI"
	// Sri Lanka
	CountryLK Country = "LK"
	// Liberia
	CountryLR Country = "LR"
	// Lesotho
	CountryLS Country = "LS"
	// Lithuania
	CountryLT Country = "LT"
	// Luxembourg
	CountryLU Country = "LU"
	// Latvia
	CountryLV Country = "LV"
	// Libyan Arab Jamahiriya
	CountryLY Country = "LY"
	// Morocco
	CountryMA Country = "MA"
	// Monaco
	CountryMC Country = "MC"
	// Moldova, Republic of
	CountryMD Country = "MD"
	// Montenegro
	CountryME Country = "ME"
	// Saint Martin
	CountryMF Country = "MF"
	// Madagascar
	CountryMG Country = "MG"
	// Marshall Islands
	CountryMH Country = "MH"
	// Macedonia
	CountryMK Country = "MK"
	// Mali
	CountryML Country = "ML"
	// Myanmar
	CountryMM Country = "MM"
	// Mongolia
	CountryMN Country = "MN"
	// Macao
	CountryMO Country = "MO"
	// Northern Mariana Islands
	CountryMP Country = "MP"
	// Martinique
	CountryMQ Country = "MQ"
	// Mauritania
	CountryMR Country = "MR"
	// Montserrat
	CountryMS Country = "MS"
	// Malta
	CountryMT Country = "MT"
	// Mauritius
	CountryMU Country = "MU"
	// Maldives
	CountryMV Country = "MV"
	// Malawi
	CountryMW Country = "MW"
	// Mexico
	CountryMX Country = "MX"
	// Malaysia
	CountryMY Country = "MY"
	// Mozambique
	CountryMZ Country = "MZ"
	// Namibia
	CountryNA Country = "NA"
	// New Caledonia
	CountryNC Country = "NC"
	// Niger
	CountryNE Country = "NE"
	// Norfolk Island
	CountryNF Country = "NF"
	// Nigeria
	CountryNG Country = "NG"
	// Nicaragua
	CountryNI Country = "NI"
	// Netherlands
	CountryNL Country = "NL"
	// Norway
	CountryNO Country = "NO"
	// Nepal
	CountryNP Country = "NP"
	// Nauru
	CountryNR Country = "NR"
	// Niue
	CountryNU Country = "NU"
	// New Zealand
	CountryNZ Country = "NZ"
	// Oman
	CountryOM Country = "OM"
	// Panama
	CountryPA Country = "PA"
	// Peru
	CountryPE Country = "PE"
	// French Polynesia
	CountryPF Country = "PF"
	// Papua New Guinea
	CountryPG Country = "PG"
	// Philippines
	CountryPH Country = "PH"
	// Pakistan
	CountryPK Country = "PK"
	// Poland
	CountryPL Country = "PL"
	// Saint Pierre and Miquelon
	CountryPM Country = "PM"
	// Pitcairn
	CountryPN Country = "PN"
	// Puerto Rico
	CountryPR Country = "PR"
	// Palestinian Territory
	CountryPS Country = "PS"
	// Portugal
	CountryPT Country = "PT"
	// Palau
	CountryPW Country = "PW"
	// Paraguay
	CountryPY Country = "PY"
	// Qatar
	CountryQA Country = "QA"
	// Reunion
	CountryRE Country = "RE"
	// Romania
	CountryRO Country = "RO"
	// Serbia
	CountryRS Country = "RS"
	// Russian Federation
	CountryRU Country = "RU"
	// Rwanda
	CountryRW Country = "RW"
	// Saudi Arabia
	CountrySA Country = "SA"
	// Solomon Islands
	CountrySB Country = "SB"
	// Seychelles
	CountrySC Country = "SC"
	// Sudan
	CountrySD Country = "SD"
	// Sweden
	CountrySE Country = "SE"
	// Singapore
	CountrySG Country = "SG"
	// Saint Helena
	CountrySH Country = "SH"
	// Slovenia
	CountrySI Country = "SI"
	// Svalbard and Jan Mayen
	CountrySJ Country = "SJ"
	// Slovakia
	CountrySK Country = "SK"
	// Sierra Leone
	CountrySL Country = "SL"
	// San Marino
	CountrySM Country = "SM"
	// Senegal
	CountrySN Country = "SN"
	// Somalia
	CountrySO Country = "SO"
	// Suriname
	CountrySR Country = "SR"
	// South Sudan
	CountrySS Country = "SS"
	// Sao Tome and Principe
	CountryST Country = "ST"
	// El Salvador
	CountrySV Country = "SV"
	// Sint Maarten (Dutch part)
	CountrySX Country = "SX"
	// Syrian Arab Republic
	CountrySY Country = "SY"
	// Swaziland
	CountrySZ Country = "SZ"
	// Turks and Caicos Islands
	CountryTC Country = "TC"
	// Chad
	CountryTD Country = "TD"
	// French Southern Territories
	CountryTF Country = "TF"
	// Togo
	CountryTG Country = "TG"
	// Thailand
	CountryTH Country = "TH"
	// Tajikistan
	CountryTJ Country = "TJ"
	// Tokelau
	CountryTK Country = "TK"
	// Timor-Leste
	CountryTL Country = "TL"
	// Turkmenistan
	CountryTM Country = "TM"
	// Tunisia
	CountryTN Country = "TN"
	// Tonga
	CountryTO Country = "TO"
	// Turkey
	CountryTR Country = "TR"
	// Trinidad and Tobago
	CountryTT Country = "TT"
	// Tuvalu
	CountryTV Country = "TV"
	// Taiwan
	CountryTW Country = "TW"
	// Tanzania, United Republic of
	CountryTZ Country = "TZ"
	// Ukraine
	CountryUA Country = "UA"
	// Uganda
	CountryUG Country = "UG"
	// United States Minor Outlying Islands
	CountryUM Country = "UM"
	// United States
	CountryUS Country = "US"
	// Uruguay
	CountryUY Country = "UY"
	// Uzbekistan
	CountryUZ Country = "UZ"
	// Holy See (Vatican City State)
	CountryVA Country = "VA"
	// Saint Vincent and the Grenadines
	CountryVC Country = "VC"
	// Venezuela
	CountryVE Country = "VE"
	// Virgin Islands, British
	CountryVG Country = "VG"
	// Virgin Islands, U.S.
	CountryVI Country = "VI"
	// Vietnam
	CountryVN Country = "VN"
	// Vanuatu
	CountryVU Country = "VU"
	// Wallis and Futuna
	CountryWF Country = "WF"
	// Samoa
	CountryWS Country = "WS"
	// Kosovo
	CountryXK Country = "XK"
	// Yemen
	CountryYE Country = "YE"
	// Mayotte
	CountryYT Country = "YT"
	// South Africa
	CountryZA Country = "ZA"
	// Zambia
	CountryZM Country = "ZM"
	// Zimbabwe
	CountryZW Country = "ZW"
)

func (s Country) StringPtr() *string {
	str := string(s)
	return &str
}

// This type supports the two digit codes of the US states and territories. They are enumerated in the XML schema.
type State string

const (
	StateUnknown State = ""
	// Alaska
	StateAK State = "AK"
	// Alabama
	StateAL State = "AL"
	// Arkansas
	StateAR State = "AR"
	// Arizona
	StateAZ State = "AZ"
	// California
	StateCA State = "CA"
	// Colorado
	StateCO State = "CO"
	// Connecticut
	StateCT State = "CT"
	// District of Columbia
	StateDC State = "DC"
	// Delaware
	StateDE State = "DE"
	// Florida
	StateFL State = "FL"
	// Georgia
	StateGA State = "GA"
	// Guam
	StateGU State = "GU"
	// Hawaii
	StateHI State = "HI"
	// Iowa
	StateIA State = "IA"
	// Idaho
	StateID State = "ID"
	// Illinois
	StateIL State = "IL"
	// Indiana
	StateIN State = "IN"
	// Kansas
	StateKS State = "KS"
	// Kentucky
	StateKY State = "KY"
	// Louisiana
	StateLA State = "LA"
	// Massachusetts
	StateMA State = "MA"
	// Maryland
	StateMD State = "MD"
	// Maine
	StateME State = "ME"
	// Michigan
	StateMI State = "MI"
	// Minnesota
	StateMN State = "MN"
	// Missouri
	StateMO State = "MO"
	// Mississippi
	StateMS State = "MS"
	// Montana
	StateMT State = "MT"
	// North Carolina
	StateNC State = "NC"
	// North Dakota
	StateND State = "ND"
	// Nebraska
	StateNE State = "NE"
	// New Hampshire
	StateNH State = "NH"
	// New Jersey
	StateNJ State = "NJ"
	// New Mexico
	StateNM State = "NM"
	// Nevada
	StateNV State = "NV"
	// New York
	StateNY State = "NY"
	// Ohio
	StateOH State = "OH"
	// Oklahoma
	StateOK State = "OK"
	// Oregon
	StateOR State = "OR"
	// Pennsylvania
	StatePA State = "PA"
	// Puerto Rico
	StatePR State = "PR"
	// Rhode Island
	StateRI State = "RI"
	// South Carolina
	StateSC State = "SC"
	// South Dakota
	StateSD State = "SD"
	// Tennessee
	StateTN State = "TN"
	// Texas
	StateTX State = "TX"
	// Utah
	StateUT State = "UT"
	// Virginia
	StateVA State = "VA"
	// Virgin Islands
	StateVI State = "VI"
	// Vermont
	StateVT State = "VT"
	// Washington
	StateWA State = "WA"
	// Wisconsin
	StateWI State = "WI"
	// West Virginia
	StateWV State = "WV"
	// Wyoming
	StateWY State = "WY"
)

func (s State) StringPtr() *string {
	str := string(s)
	return &str
}
